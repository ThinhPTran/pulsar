<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>co.paralleluniverse.pulsar.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Pulsar</span> <span class="project-version">0.7.7-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>co</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>paralleluniverse</span></div></div></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pulsar</span></div></div></li><li class="depth-4 branch"><a href="co.paralleluniverse.pulsar.actors.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>actors</span></div></a></li><li class="depth-4 branch"><a href="co.paralleluniverse.pulsar.async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>async</span></div></a></li><li class="depth-4 branch current"><a href="co.paralleluniverse.pulsar.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-4 branch"><a href="co.paralleluniverse.pulsar.dataflow.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dataflow</span></div></a></li><li class="depth-4 branch"><a href="co.paralleluniverse.pulsar.interop.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>interop</span></div></a></li><li class="depth-4 branch"><a href="co.paralleluniverse.pulsar.lazyseq.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lazyseq</span></div></a></li><li class="depth-4"><a href="co.paralleluniverse.pulsar.rx.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rx</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var--.3Etimeunit"><div class="inner"><span>-&gt;timeunit</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-alive.3F"><div class="inner"><span>alive?</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-await"><div class="inner"><span>await</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-channel"><div class="inner"><span>channel</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-close.21"><div class="inner"><span>close!</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-closed.3F"><div class="inner"><span>closed?</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-convert-duration"><div class="inner"><span>convert-duration</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-create-fiber"><div class="inner"><span>create-fiber</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-current-fiber"><div class="inner"><span>current-fiber</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-current-strand"><div class="inner"><span>current-strand</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-dbg"><div class="inner"><span>dbg</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-default-fiber-scheduler"><div class="inner"><span>default-fiber-scheduler</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-defsfn"><div class="inner"><span>defsfn</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-double-channel"><div class="inner"><span>double-channel</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-fiber"><div class="inner"><span>fiber</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-fiber-.3Efuture"><div class="inner"><span>fiber-&gt;future</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-float-channel"><div class="inner"><span>float-channel</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-int-channel"><div class="inner"><span>int-channel</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-join"><div class="inner"><span>join</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-letsfn"><div class="inner"><span>letsfn</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-long-channel"><div class="inner"><span>long-channel</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-promise"><div class="inner"><span>promise</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-rcv"><div class="inner"><span>rcv</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-rcv-double"><div class="inner"><span>rcv-double</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-rcv-float"><div class="inner"><span>rcv-float</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-rcv-int"><div class="inner"><span>rcv-int</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-rcv-into"><div class="inner"><span>rcv-into</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-rcv-long"><div class="inner"><span>rcv-long</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-sel"><div class="inner"><span>sel</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-select"><div class="inner"><span>select</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-seq-.3Echannel"><div class="inner"><span>seq-&gt;channel</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-sfn"><div class="inner"><span>sfn</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-singleton-channel"><div class="inner"><span>singleton-channel</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-sleep"><div class="inner"><span>sleep</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-snd"><div class="inner"><span>snd</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-snd-double"><div class="inner"><span>snd-double</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-snd-float"><div class="inner"><span>snd-float</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-snd-int"><div class="inner"><span>snd-int</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-snd-long"><div class="inner"><span>snd-long</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-snd-seq"><div class="inner"><span>snd-seq</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-spawn-fiber"><div class="inner"><span>spawn-fiber</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-spawn-thread"><div class="inner"><span>spawn-thread</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-sreify"><div class="inner"><span>sreify</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-start"><div class="inner"><span>start</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-strampoline"><div class="inner"><span>strampoline</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-subscribe.21"><div class="inner"><span>subscribe!</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-suspendable.21"><div class="inner"><span>suspendable!</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-suspendable.3F"><div class="inner"><span>suspendable?</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-tagged"><div class="inner"><span>tagged</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-ticker-consumer"><div class="inner"><span>ticker-consumer</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-topic"><div class="inner"><span>topic</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-try-rcv"><div class="inner"><span>try-rcv</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-try-snd"><div class="inner"><span>try-snd</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-try-snd-double"><div class="inner"><span>try-snd-double</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-try-snd-float"><div class="inner"><span>try-snd-float</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-try-snd-int"><div class="inner"><span>try-snd-int</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-try-snd-long"><div class="inner"><span>try-snd-long</span></div></a></li><li class="depth-1"><a href="co.paralleluniverse.pulsar.core.html#var-unsubscribe.21"><div class="inner"><span>unsubscribe!</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">co.paralleluniverse.pulsar.core</h1><div class="doc"><pre class="plaintext">Pulsar is an implementation of lightweight threads (fibers),
Go-like channles and Erlang-like actors for the JVM</pre></div><div class="public anchor" id="var--.3Etimeunit"><h3>-&gt;timeunit</h3><div class="usage"><code>(-&gt;timeunit x)</code></div><div class="doc"><pre class="plaintext">Constructs an instance of `java.util.concurrent.TimeUnit`.
If argument x is already an instance of `TimeUnit`, the function returns x.
Otherwise, x *must* be a keyword, in which case the following conversion
is performed:

:nanoseconds | :nanos | :ns   -&gt; TimeUnit/NANOSECONDS
:microseconds | :us           -&gt; TimeUnit/MICROSECONDS
:milliseconds | :millis | :ms -&gt; TimeUnit/MILLISECONDS
:seconds | :sec               -&gt; TimeUnit/SECONDS
:minutes | :mins              -&gt; TimeUnit/MINUTES
:hours | :hrs                 -&gt; TimeUnit/HOURS
:days                         -&gt; TimeUnit/DAYS
</pre></div></div><div class="public anchor" id="var-alive.3F"><h3>alive?</h3><div class="usage"><code>(alive? a)</code></div><div class="doc"><pre class="plaintext">Tests whether or not a strand is alive. 
A strand is alive if it has been started but has not yet died.</pre></div></div><div class="public anchor" id="var-await"><h3>await</h3><h4 class="type">macro</h4><div class="usage"><code>(await f &amp; args)</code></div><div class="doc"><pre class="plaintext">Calls f, which takes a callback of a single argument as its last parameter,
with arguments args, and blocks the current fiber until the callback is called,
then returns the value passed to the callback.</pre></div></div><div class="public anchor" id="var-channel"><h3>channel</h3><div class="usage"><code>(channel capacity overflow-policy single-producer? single-consumer?)</code><code>(channel capacity overflow-policy)</code><code>(channel capacity)</code><code>(channel)</code></div><div class="doc"><pre class="plaintext">Creates a new channel.

Optional arguments:
capacity         - specifies how many messages the channel can contain (until they are consumed)
                   * A value of `0` designates a *transfer channel*, that blocks both `snd` and `rcv`
                     until a corresponding operation (`rcv` or `snd` respectively) is called.
                   * A value of `-1` creates an unbounded channel.

                   default: 0

overflow-policy  - specifies what `snd` does when the channel's capacity is exhausted.
                   May be one of:
                   * :throw    - throws an exception.
                   * :block    - blocks until a message is consumed and room is available
                   * :drop     - the message is silently dropped
                   * :displace - the old message waiting in the queue is discarded to make room for the new message.

                   default: :block

single-producer? - specifies if the channel should be single-producer.

                   default: false

single-consumer? - specifies if the channel should be single-consumer.

                   default: true

The default channel capacity is 0 and the default policy is :block</pre></div></div><div class="public anchor" id="var-close.21"><h3>close!</h3><div class="usage"><code>(close! channel)</code><code>(close! channel exception)</code></div><div class="doc"><pre class="plaintext">Closes a channel.
Messages already in the channel will be received, but all future attempts at `snd`
will silently discard the message. After all messages have been consumed, `rcv` will
return `nil`.

If an exception is passed as the second argument, then the same will happen, except after
all messages are consumed, the passed exception will be thrown by `rcv`, wrapped in a
`co.paralleluniverse.strands.channels.ProducerException`.</pre></div></div><div class="public anchor" id="var-closed.3F"><h3>closed?</h3><div class="usage"><code>(closed? channel)</code></div><div class="doc"><pre class="plaintext">Tests whether a channel has been closed and contains no more messages that 
can be received.</pre></div></div><div class="public anchor" id="var-convert-duration"><h3>convert-duration</h3><div class="usage"><code>(convert-duration x from-unit to-unit)</code></div><div class="doc"><pre class="plaintext">Converts a time duration from one time unit to another.
x is the duration; `from-unit` and `to-unit` are the source
and target units repsectively, given as either a j.u.c.TimeUnit instance
or as a keyword, as specified by `-&gt;timeunit`.</pre></div></div><div class="public anchor" id="var-create-fiber"><h3>create-fiber</h3><div class="usage"><code>(create-fiber &amp; args)</code></div><div class="doc"><pre class="plaintext">Creates, but does not start a new fiber (a lightweight thread) running in a fork/join pool.

It is much preferable to use `spawn-fiber`.</pre></div></div><div class="public anchor" id="var-current-fiber"><h3>current-fiber</h3><div class="usage"><code>(current-fiber)</code></div><div class="doc"><pre class="plaintext">Returns the currently running lightweight-thread or `nil` if none.
</pre></div></div><div class="public anchor" id="var-current-strand"><h3>current-strand</h3><div class="usage"><code>(current-strand)</code></div><div class="doc"><pre class="plaintext">Returns the currently running fiber (if running in fiber)
or current thread (if not).</pre></div></div><div class="public anchor" id="var-dbg"><h3>dbg</h3><h4 class="type">macro</h4><div class="usage"><code>(dbg &amp; body)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-default-fiber-scheduler"><h3>default-fiber-scheduler</h3><div class="usage"></div><div class="doc"><pre class="plaintext">A global fiber scheduler. The scheduler uses all available processor cores.
</pre></div></div><div class="public anchor" id="var-defsfn"><h3>defsfn</h3><h4 class="type">macro</h4><div class="usage"><code>(defsfn &amp; expr)</code></div><div class="doc"><pre class="plaintext">Defines a suspendable function that can be used by a fiber or actor.
Used exactly like `defn`</pre></div></div><div class="public anchor" id="var-double-channel"><h3>double-channel</h3><div class="usage"><code>(double-channel size overflow-policy)</code><code>(double-channel size)</code><code>(double-channel)</code></div><div class="doc"><pre class="plaintext">Creates a double channel
</pre></div></div><div class="public anchor" id="var-fiber"><h3>fiber</h3><h4 class="type">macro</h4><div class="usage"><code>(fiber &amp; body)</code></div><div class="doc"><pre class="plaintext">Runs the given body in a newly created fiber and returns it.
</pre></div></div><div class="public anchor" id="var-fiber-.3Efuture"><h3>fiber-&gt;future</h3><div class="usage"><code>(fiber-&gt;future f)</code></div><div class="doc"><pre class="plaintext">Takes a spawned fiber yields a future object that will
invoke the function in another thread, and will cache the result and
return it on all subsequent calls to deref/@. If the computation has
not yet finished, calls to deref/@ will block, unless the variant
of deref with timeout is used. See also - realized?.</pre></div></div><div class="public anchor" id="var-float-channel"><h3>float-channel</h3><div class="usage"><code>(float-channel size overflow-policy)</code><code>(float-channel size)</code><code>(float-channel)</code></div><div class="doc"><pre class="plaintext">Creates a float channel
</pre></div></div><div class="public anchor" id="var-int-channel"><h3>int-channel</h3><div class="usage"><code>(int-channel size overflow-policy)</code><code>(int-channel size)</code><code>(int-channel)</code></div><div class="doc"><pre class="plaintext">Creates an int channel
</pre></div></div><div class="public anchor" id="var-join"><h3>join</h3><div class="usage"><code>(join s)</code><code>(join timeout unit s)</code></div><div class="doc"><pre class="plaintext">Awaits the termination of the given strand or strands, and returns
their result, if applicable.

If a single strand is given, its result is returned;
if a collection - then a collection of the respective results.

Note that for threads, the result is always `nil`, as threads don't return a value.

If a timeout is supplied and it elapses before the strand has terminated,
a j.u.c.TimeoutException is thrown.

s       - either a strand or a collection of strands.
timeout - how long to wait for the strands termination
unit    - the unit of the timeout duration. TimeUnit or keyword as in `-&gt;timeunit`</pre></div></div><div class="public anchor" id="var-letsfn"><h3>letsfn</h3><h4 class="type">macro</h4><div class="usage"><code>(letsfn fnspecs &amp; body)</code></div><div class="doc"><pre class="plaintext">Defines a local suspendable function that can be used by a fiber or actor.
Used exactly like `letfn`</pre></div></div><div class="public anchor" id="var-long-channel"><h3>long-channel</h3><div class="usage"><code>(long-channel size overflow-policy)</code><code>(long-channel size)</code><code>(long-channel)</code></div><div class="doc"><pre class="plaintext">Creates a long channel
</pre></div></div><div class="public anchor" id="var-promise"><h3>promise</h3><div class="usage"><code>(promise f)</code><code>(promise)</code></div><div class="doc"><pre class="plaintext">Returns a promise object that can be read with deref/@, and set,
once only, with deliver. Calls to deref/@ prior to delivery will
block, unless the variant of deref with timeout is used. All
subsequent derefs will return the same delivered value without
blocking. See also - realized?.

Unlike clojure.core/promise, this promise object can be used inside Pulsar fibers.</pre></div></div><div class="public anchor" id="var-rcv"><h3>rcv</h3><div class="usage"><code>(rcv channel)</code><code>(rcv channel timeout unit)</code></div><div class="doc"><pre class="plaintext">Receives a message from a channel.
This function will block until a message is available or until the timeout,
if specified, expires.
If a timeout is given, and it expires, rcv returns nil.
Otherwise, the message is returned.</pre></div></div><div class="public anchor" id="var-rcv-double"><h3>rcv-double</h3><h4 class="type">macro</h4><div class="usage"><code>(rcv-double channel)</code><code>(rcv-double channel timeout unit)</code></div><div class="doc"><pre class="plaintext">Receives a double value from a double-channel.

See: `rcv`</pre></div></div><div class="public anchor" id="var-rcv-float"><h3>rcv-float</h3><h4 class="type">macro</h4><div class="usage"><code>(rcv-float channel)</code><code>(rcv-float channel timeout unit)</code></div><div class="doc"><pre class="plaintext">Receives a float value from a float-channel.

See: `rcv`</pre></div></div><div class="public anchor" id="var-rcv-int"><h3>rcv-int</h3><h4 class="type">macro</h4><div class="usage"><code>(rcv-int channel)</code><code>(rcv-int channel timeout unit)</code></div><div class="doc"><pre class="plaintext">Receives an int value from an int-channel.

See: `rcv`</pre></div></div><div class="public anchor" id="var-rcv-into"><h3>rcv-into</h3><div class="usage"><code>(rcv-into to channel n)</code></div><div class="doc"><pre class="plaintext">Receives at most n values from the given channel and conjoins them
into the to collection</pre></div></div><div class="public anchor" id="var-rcv-long"><h3>rcv-long</h3><h4 class="type">macro</h4><div class="usage"><code>(rcv-long channel)</code><code>(rcv-long channel timeout unit)</code></div><div class="doc"><pre class="plaintext">Receives a long value from a long-channel.

See: `rcv`</pre></div></div><div class="public anchor" id="var-sel"><h3>sel</h3><div class="usage"><code>(sel ports &amp; {:as opts})</code></div><div class="doc"><pre class="plaintext">Performs up to one of several given channel operations.
sel takes a collection containing *channel operation descriptors*. A descriptor is 
either a channel or a pair (vector) of a channel and a message. 
Each channel in the sequence represents a `rcv` attempt, and each channel-message pair 
represents a `snd` attempt. 
The `sel` function performs at most one operation on the sequence, a `rcv` or a `snd`, 
which is determined by the first operation that can succeed. If no operation can be 
carried out immediately, `sel` will block until an operation can be performed, or the
optionally specified timeout expires.
If two or more operations are available at the same time, one of them will be chosen
at random, unless the `:priority` option is set to `true`.

Options:
:priority bool -  If set to `true`, then whenever two or more operations are available
                  the first among them, in the order they are listed in the `ports` collection,
                  will be the one executed.
:timeout millis - If timeout is set and expires before any of the operations are available,
                  the function will return `nil`

Returns:
If an operation succeeds, returns a vector `[m ch]` with `m` being the message received if the
operation is a `rcv`, or `nil` if it's a `snd`, and `ch` is the channel on which the succesful
opration was performed.
If a timeout is set and expires before any of the operations are available, returns `nil`.</pre></div></div><div class="public anchor" id="var-select"><h3>select</h3><h4 class="type">macro</h4><div class="usage"><code>(select &amp; clauses)</code></div><div class="doc"><pre class="plaintext">Performs a very similar operation to `sel`, but allows you to specify an action to perform depending 
on which operation has succeeded.
Takes an even number of expressions, ordered as (ops1, action1, ops2, action2 ...) with the ops being 
a channel operation descriptior (remember: a descriptor is either a channel for an `rcv` operation, 
or a vector of a channel and a message specifying a `snd` operation) or a collection of descriptors, 
and the actions are Clojure expressions. 
Like `sel`, `select` performs at most one operation, in which case it will run the operation's 
respective action and return its result.

An action expression can bind values to the operations results. 
The action expression may begin with a vector of one or two symbols. In that case, the first symbol 
will be bound to the message returned from the successful receive in the respective ops clause 
(or `nil` if the successful operation is a `snd`), and the second symbol, if present, will be bound 
to the successful operation's channel.

Like `sel`, `select` blocks until an operation succeeds, or, if a `:timeout` option is specified, 
until the timeout (in milliseconds) elapses. If a timeout is specfied and elapses, `select` will run 
the action in an optional `:else` clause and return its result, or, if an `:else` clause is not present, 
`select` will return `nil`.

Example:

(select :timeout 100 
       c1 ([v] (println "received" v))
       [[c2 m2] [c3 m3]] ([v c] (println "sent to" c))
       :else "timeout!")

In the example, if a message is received from channel `c1`, then it will be printed. 
If a message is sent to either `c2` or `c3`, then the identity of the channel will be printed, 
and if the 100 ms timeout elapses then "timeout!" will be printed.</pre></div></div><div class="public anchor" id="var-seq-.3Echannel"><h3>seq-&gt;channel</h3><div class="usage"><code>(seq-&gt;channel x)</code></div><div class="doc"><pre class="plaintext">Turns a sequence into a receive port that receives all values in the sequence
</pre></div></div><div class="public anchor" id="var-sfn"><h3>sfn</h3><h4 class="type">macro</h4><div class="usage"><code>(sfn &amp; expr)</code></div><div class="doc"><pre class="plaintext">Creates a suspendable function that can be used by a fiber or actor.
Used exactly like `fn`</pre></div></div><div class="public anchor" id="var-singleton-channel"><h3>singleton-channel</h3><div class="usage"><code>(singleton-channel x)</code></div><div class="doc"><pre class="plaintext">Returns a channel that receives a single, given value
and then closes</pre></div></div><div class="public anchor" id="var-sleep"><h3>sleep</h3><div class="usage"><code>(sleep ms)</code><code>(sleep timeout unit)</code></div><div class="doc"><pre class="plaintext">Suspends the current strand.
</pre></div></div><div class="public anchor" id="var-snd"><h3>snd</h3><div class="usage"><code>(snd channel message)</code></div><div class="doc"><pre class="plaintext">Sends a message to a channel.
If the channel's overflow policy is `:block` than this function will block
if the channels' capacity is exceeded.</pre></div></div><div class="public anchor" id="var-snd-double"><h3>snd-double</h3><h4 class="type">macro</h4><div class="usage"><code>(snd-double channel message)</code></div><div class="doc"><pre class="plaintext">Sends a double value to a double-channel.  

See: `snd`</pre></div></div><div class="public anchor" id="var-snd-float"><h3>snd-float</h3><h4 class="type">macro</h4><div class="usage"><code>(snd-float channel message)</code></div><div class="doc"><pre class="plaintext">Sends a float value to a float-channel.  

See: `snd`</pre></div></div><div class="public anchor" id="var-snd-int"><h3>snd-int</h3><h4 class="type">macro</h4><div class="usage"><code>(snd-int channel message)</code></div><div class="doc"><pre class="plaintext">Sends an int value to an int-channel.

See: `snd`</pre></div></div><div class="public anchor" id="var-snd-long"><h3>snd-long</h3><h4 class="type">macro</h4><div class="usage"><code>(snd-long channel message)</code></div><div class="doc"><pre class="plaintext">Sends a long value to a long-channel.  

See: `snd`</pre></div></div><div class="public anchor" id="var-snd-seq"><h3>snd-seq</h3><div class="usage"><code>(snd-seq channel ms)</code></div><div class="doc"><pre class="plaintext">Sends a sequence of messages to a channel
</pre></div></div><div class="public anchor" id="var-spawn-fiber"><h3>spawn-fiber</h3><h4 class="type">macro</h4><div class="usage"><code>(spawn-fiber :name? :stack-size? :scheduler? f &amp; args)</code></div><div class="doc"><pre class="plaintext">Creates and starts a new fiber.

f - the function to run in the fiber.
args - (optional) arguments for the function

Options:
:name str     - the fiber's name
:stack-size n - the fiber's initial stack size
:scheduler    - the fiber schdeuler in which the fiber will run
</pre></div></div><div class="public anchor" id="var-spawn-thread"><h3>spawn-thread</h3><div class="usage"><code>(spawn-thread :name? f &amp; args)</code></div><div class="doc"><pre class="plaintext">Creates and starts a new thread.

f - the function to run in the thread.
args - (optional) arguments to pass to the function

Options:
:name str     - the thread's name</pre></div></div><div class="public anchor" id="var-sreify"><h3>sreify</h3><h4 class="type">macro</h4><div class="usage"><code>(sreify &amp; expr)</code></div><div class="doc"><pre class="plaintext">Creates a suspendable implementation of a protocol or interface.
sreify is to reify what sfn is to fn.</pre></div></div><div class="public anchor" id="var-start"><h3>start</h3><div class="usage"><code>(start fiber)</code></div><div class="doc"><pre class="plaintext">Starts a fiber created with `create-fiber`.
</pre></div></div><div class="public anchor" id="var-strampoline"><h3>strampoline</h3><div class="usage"><code>(strampoline f)</code><code>(strampoline f &amp; args)</code></div><div class="doc"><pre class="plaintext">A suspendable version of trampoline. Should be used to implement
finite-state-machine actors.

trampoline can be used to convert algorithms requiring mutual
recursion without stack consumption. Calls f with supplied args, if
any. If f returns a fn, calls that fn with no arguments, and
continues to repeat, until the return value is not a fn, then
returns that non-fn value. Note that if you want to return a fn as a
final value, you must wrap it in some data structure and unpack it
after trampoline returns.</pre></div></div><div class="public anchor" id="var-subscribe.21"><h3>subscribe!</h3><div class="usage"><code>(subscribe! topic channel)</code></div><div class="doc"><pre class="plaintext">Subscribes a channel to a topic.
The subscribed channel will receive all messages sent to the topic.</pre></div></div><div class="public anchor" id="var-suspendable.21"><h3>suspendable!</h3><div class="usage"><code>(suspendable! f)</code><code>(suspendable! x prot)</code></div><div class="doc"><pre class="plaintext">Makes a function suspendable.
</pre></div></div><div class="public anchor" id="var-suspendable.3F"><h3>suspendable?</h3><div class="usage"><code>(suspendable? f)</code></div><div class="doc"><pre class="plaintext">Returns true of a function has been instrumented as suspendable; false otherwise.
</pre></div></div><div class="public anchor" id="var-tagged"><h3>tagged</h3><div class="usage"><code>(tagged tag sym)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-ticker-consumer"><h3>ticker-consumer</h3><div class="usage"><code>(ticker-consumer ticker)</code></div><div class="doc"><pre class="plaintext">Creates a rcv-port (read-only channel) that returns messages from a *ticker channel*.
A ticker channel is a bounded channel with an overflow policy of :displace.

Different ticker consumers are independent (a message received from one is not removed from others),
and guarantee monotonicty (messages are received in order), but if messages are sent to the
ticker channel faster than they are consumed then messages can be lost.</pre></div></div><div class="public anchor" id="var-topic"><h3>topic</h3><div class="usage"><code>(topic)</code></div><div class="doc"><pre class="plaintext">Creates a new topic.
A topic is a send-port (a write-only channel) that forwards every message sent to it
to a group of subscribed channels.
Use `subscribe!` and `unsubscribe!` to subscribe and unsubscribe a channel to or from
the topic.</pre></div></div><div class="public anchor" id="var-try-rcv"><h3>try-rcv</h3><div class="usage"><code>(try-rcv channel)</code></div><div class="doc"><pre class="plaintext">Attempts to immediately (without blocking) receive a message from a channel.
Returns the message if one is immediately available; `nil` otherwise.
This function never blocks.</pre></div></div><div class="public anchor" id="var-try-snd"><h3>try-snd</h3><div class="usage"><code>(try-snd channel message)</code></div><div class="doc"><pre class="plaintext">Tries to immediately send a message to a channel.
If the channel's capacity is exceeded, this function fails and returns `false`.
Returns `true` if the operation succeeded; `false` otherwise.
This function never blocks.</pre></div></div><div class="public anchor" id="var-try-snd-double"><h3>try-snd-double</h3><h4 class="type">macro</h4><div class="usage"><code>(try-snd-double channel message)</code></div><div class="doc"><pre class="plaintext">Tries to immediately send a double value to a double-channel.
Returns `true` if successful, `false` otherwise.  

See: `try-snd`</pre></div></div><div class="public anchor" id="var-try-snd-float"><h3>try-snd-float</h3><h4 class="type">macro</h4><div class="usage"><code>(try-snd-float channel message)</code></div><div class="doc"><pre class="plaintext">Tries to immediately send a float value to a float-channel.
Returns `true` if successful, `false` otherwise.  

See: `try-snd`</pre></div></div><div class="public anchor" id="var-try-snd-int"><h3>try-snd-int</h3><h4 class="type">macro</h4><div class="usage"><code>(try-snd-int channel message)</code></div><div class="doc"><pre class="plaintext">Tries to immediately send an int value to an int-channel.
Returns `true` if successful, `false` otherwise.

See: `try-snd`</pre></div></div><div class="public anchor" id="var-try-snd-long"><h3>try-snd-long</h3><h4 class="type">macro</h4><div class="usage"><code>(try-snd-long channel message)</code></div><div class="doc"><pre class="plaintext">Tries to immediately send a long value to a long-channel.
Returns `true` if successful, `false` otherwise.  

See: `try-snd`</pre></div></div><div class="public anchor" id="var-unsubscribe.21"><h3>unsubscribe!</h3><div class="usage"><code>(unsubscribe! topic channel)</code></div><div class="doc"><pre class="plaintext">Unsubscribes a channel from a topic.
The channel will stop receiving messages sent to the topic.</pre></div></div></div></body></html>